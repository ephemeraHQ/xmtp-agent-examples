---
alwaysApply: true
---

# Writing XMTP Agents

You're an expert in writing TypeScript with Node.js. Generate **high-quality XMTP Agents** that adhere to the following best practices:

## Guidelines

1. Use modern TypeScript patterns and ESM modules. All examples should be structured as ES modules with `import` statements rather than CommonJS `require()`.

2. Use the XMTP Agent SDK (@xmtp/agent-sdk) which provides an event-driven, middleware-powered approach to building messaging agents.

3. Only import from @xmtp/agent-sdk for XMTP functionality. Do not import from any other XMTP-related packages or URLs. Specifically:
   - Never use the deprecated @xmtp/xmtp-js library or @xmtp/node-sdk
   - Always import directly from @xmtp/agent-sdk as shown below:

   ```typescript
   // CORRECT:
   import {
     Agent,
     filter,
     withFilter,
     type AgentContext,
   } from "@xmtp/agent-sdk";

   // INCORRECT - DEPRECATED:
   import { Client } from "@xmtp/xmtp-js";
   import { Client } from "@xmtp/node-sdk";
   ```

4. Follow the consistent pattern for initializing XMTP agents using environment variables:

   ```typescript
   // Load environment variables from .env file
   process.loadEnvFile(".env");

   // Create agent using environment variables (simplest approach)
   const agent = await Agent.create();

   // Or with custom options
   const agent = await Agent.create(undefined, {
     env: "dev", // or 'production'
     dbPath: null, // in-memory store; provide a path to persist
     codecs: [new CustomCodec()], // optional custom content types
   });
   ```

5. Use proper environment variable validation. The Agent SDK supports these environment variables:
   - `XMTP_WALLET_KEY` - Private key for wallet
   - `XMTP_ENV` - Network environment (dev, production)
   - `XMTP_DB_ENCRYPTION_KEY` - Database encryption key
   - `XMTP_FORCE_DEBUG` - Activate debugging logs
   - `XMTP_FORCE_REVOKE_INSTALLATIONS` - Remove other installations

6. Use event-driven architecture with the Agent's EventEmitter interface:

   ```typescript
   // Listen for incoming messages
   agent.on("message", async (ctx) => {
     await ctx.conversation.send("Hello from my XMTP Agent! üëã");
   });

   // Listen for lifecycle events
   agent.on("start", () => {
     console.log("Agent started successfully");
   });

   agent.on("error", (error) => {
     console.error("Agent error", error);
   });

   // Start the agent
   await agent.start();
   ```

7. Use built-in filters to handle specific message types efficiently:

   ```typescript
   import { filter, withFilter } from "@xmtp/agent-sdk";

   // Using filter in message handler
   agent.on(
     "message",
     withFilter(filter.startsWith("@agent"), async (ctx) => {
       await ctx.conversation.send("How can I help you?");
     }),
   );

   // Combination of filters
   const combined = filter.and(filter.notFromSelf, filter.textOnly);

   agent.on(
     "message",
     withFilter(combined, async (ctx) => {
       await ctx.conversation.send("You sent a text message ‚úÖ");
     }),
   );
   ```

8. Leverage the rich AgentContext provided to every message handler:
   - `ctx.message` ‚Äì decoded message
   - `ctx.conversation` ‚Äì the active conversation object
   - `ctx.client` ‚Äì underlying XMTP client
   - Helper methods like `ctx.sendText()` and `ctx.sendTextReply()`

   ```typescript
   agent.on("message", async (ctx) => {
     // Access message content
     console.log(ctx.message.content);

     // Send replies using helpers
     await ctx.sendTextReply("Reply using helper ‚ú®");

     // Or use conversation directly
     await ctx.conversation.send("Direct conversation send");
   });
   ```

9. Use middleware for cross-cutting concerns like routing, analytics, rate limiting:

   ```typescript
   import { CommandRouter } from "@xmtp/agent-sdk";

   const router = new CommandRouter();

   router.command("/version", async (ctx) => {
     await ctx.conversation.send(`v${process.env.npm_package_version}`);
   });

   agent.use(router.middleware());
   ```

10. Handle custom content types by registering codecs during agent creation:

    ```typescript
    import { ReplyCodec } from "@xmtp/content-type-reply";

    const agent = await Agent.create(undefined, {
      env: "dev",
      dbPath: null,
      codecs: [new ReplyCodec()],
    });
    ```

11. Use consistent error handling pattern with type narrowing for unknown errors:

    ```typescript
    // CORRECT:
    try {
      // code that might throw
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error("Error:", errorMessage);
    }

    // INCORRECT:
    try {
      // code that might throw
    } catch (error) {
      console.error("Error:", error);
    }
    ```

12. Always use the built-in key generation command instead of creating your own script:

    Environment variables

    To run your XMTP agent, you must create a `.env` file with the following variables:

    ```bash
    XMTP_WALLET_KEY= # the private key of the wallet
    XMTP_DB_ENCRYPTION_KEY= # encryption key for the local database
    XMTP_ENV=dev # local, dev, production
    ```

    Generating XMTP Keys

    Always use the built-in key generation command instead of creating your own script:

    ```bash
    # Generate generic keys
    yarn gen:keys
    ```

    This command will:
    1. Generate a secure wallet private key
    2. Create an encryption key for the local database
    3. Output the corresponding public key
    4. Automatically append the keys to your `.env` file

    Example output in `.env`:

    ```bash
    # Generic keys
    XMTP_WALLET_KEY=0x...
    XMTP_DB_ENCRYPTION_KEY=...
    XMTP_ENV=dev
    # public key is 0x...
    ```

    > [!IMPORTANT]
    > Never create your own key generation script. The built-in command follows security best practices and uses the correct dependencies

## Example: Simple XMTP Agent

### Prompt:

"Create a simple XMTP agent that responds 'gm' to any incoming message."

### Solution:

```typescript
import { Agent } from "@xmtp/agent-sdk";

// Load environment variables from .env file
process.loadEnvFile(".env");

// Create agent using environment variables
const agent = await Agent.create();

// Respond to any incoming message
agent.on("message", async (ctx) => {
  console.log(ctx.message.content);
  await ctx.conversation.send("gm");
});

// Log when we're ready
agent.on("start", () => {
  const address = agent.client.accountIdentifier?.identifier;
  const env = agent.client.options?.env;
  const url = `http://xmtp.chat/dm/${address}?env=${env}`;
  console.log(`We are online\nAddress: ${address}\nURL: ${url}`);
});

// Start the agent
await agent.start();
```

## Example: Agent with Filters and Actions

### Prompt:

"Create an XMTP agent that sends a welcome message with inline actions for ETH price information."

### Solution:

```typescript
import { Agent, filter, withFilter, type AgentContext } from "@xmtp/agent-sdk";
import {
  ActionsCodec,
  ContentTypeActions,
  type ActionsContent,
} from "./types/ActionsContent";
import { IntentCodec, type IntentContent } from "./types/IntentContent";

process.loadEnvFile(".env");

/**
 * Send a welcome message with inline actions
 */
async function sendWelcomeWithActions(ctx: AgentContext) {
  const welcomeActions: ActionsContent = {
    id: `welcome-${Date.now()}`,
    description: `üëã Welcome! I'm your ETH price agent.

Choose an option below to get started:`,
    actions: [
      {
        id: "get-current-price",
        label: "üí∞ Get Current ETH Price",
        style: "primary",
      },
      {
        id: "get-price-chart",
        label: "üìä Get Price with 24h Change",
        style: "secondary",
      },
    ],
  };

  console.log(`‚úì Sending welcome message with actions`);
  await ctx.conversation.send(welcomeActions, ContentTypeActions);
}

/**
 * Handle intent messages (when users click action buttons)
 */
async function handleIntentMessage(
  ctx: AgentContext,
  intentContent: IntentContent,
) {
  console.log(
    `üéØ Processing intent: ${intentContent.actionId} for actions: ${intentContent.id}`,
  );

  try {
    switch (intentContent.actionId) {
      case "get-current-price":
        await ctx.conversation.send("üí∞ Current ETH Price: $3,200");
        break;

      case "get-price-chart":
        await ctx.conversation.send("üìä ETH: $3,200 (+2.5% 24h)");
        break;

      default:
        await ctx.conversation.send(
          `‚ùå Unknown action: ${intentContent.actionId}`,
        );
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("‚ùå Error processing intent:", errorMessage);
    await ctx.conversation.send(`‚ùå Error processing action: ${errorMessage}`);
  }
}

// Create agent with custom codecs
const agent = await Agent.create(undefined, {
  codecs: [new ActionsCodec(), new IntentCodec()],
});

// Filter for text-only messages (not from self)
const combined = filter.and(filter.notFromSelf, filter.textOnly);

agent.on(
  "message",
  withFilter(combined, async (ctx) => {
    if (ctx.message.contentType?.typeId === "intent") {
      // Handle action button clicks
      await handleIntentMessage(ctx, ctx.message.content as IntentContent);
    } else {
      // Send welcome message with actions
      await sendWelcomeWithActions(ctx);
    }
  }),
);

agent.on("start", () => {
  const address = agent.client.accountIdentifier?.identifier;
  const env = agent.client.options?.env;
  const url = `http://xmtp.chat/dm/${address}?env=${env}`;
  console.log(`We are online\nAddress: ${address}\nURL: ${url}`);
});

await agent.start();
```

## Core Concepts

### 1. Event-Driven Architecture

The Agent SDK uses Node's EventEmitter interface. Subscribe only to what you need:

- `message` ‚Äì a new incoming (non-self) message
- `start` / `stop` ‚Äì lifecycle events
- `error` ‚Äì surfaced errors

### 2. Middleware Support

Extend your agent with custom business logic using middlewares. Compose cross-cutting behavior like routing, telemetry, rate limiting, analytics, and feature flags.

## Middleware Reference

Middleware in the Agent SDK allows you to intercept and process messages before they reach your main event handlers. This enables powerful patterns like command routing, authentication, logging, and more.

### Basic Middleware Pattern

```typescript
import type { AgentMiddleware } from "@xmtp/agent-sdk";

// Basic middleware function
const loggingMiddleware: AgentMiddleware = async (ctx, next) => {
  console.log(`Received message: ${ctx.message.content}`);
  await next(); // Continue to next middleware or handler
};

// Use middleware
agent.use(loggingMiddleware);
```

### Command Router Middleware

The built-in `CommandRouter` provides powerful command handling:

```typescript
import { CommandRouter } from "@xmtp/agent-sdk";

const router = new CommandRouter();

// Register commands
router.command("/help", async (ctx) => {
  await ctx.conversation.send(`Available commands:
/help - Show this help message
/status - Check agent status
/version - Show version info`);
});

router.command("/status", async (ctx) => {
  await ctx.conversation.send("üü¢ Agent is running normally");
});

router.command("/version", async (ctx) => {
  await ctx.conversation.send(`v${process.env.npm_package_version}`);
});

// Handle unrecognized commands
router.default(async (ctx) => {
  await ctx.conversation.send(
    "Unknown command. Type /help for available commands.",
  );
});

// Use the router middleware
agent.use(router.middleware());
```

### Custom Middleware Examples

```typescript
// 1. Authentication middleware
const authMiddleware: AgentMiddleware = async (ctx, next) => {
  const authorizedUsers = ["admin-inbox-id", "user-inbox-id"];

  if (!authorizedUsers.includes(ctx.message.senderInboxId)) {
    await ctx.conversation.send("‚ùå Unauthorized access");
    return; // Don't call next() to stop processing
  }

  await next(); // User is authorized, continue
};

// 2. Rate limiting middleware
const rateLimitMap = new Map<string, number>();

const rateLimitMiddleware: AgentMiddleware = async (ctx, next) => {
  const senderId = ctx.message.senderInboxId;
  const now = Date.now();
  const lastMessage = rateLimitMap.get(senderId) || 0;

  if (now - lastMessage < 1000) {
    // 1 second rate limit
    await ctx.conversation.send(
      "‚è∞ Please wait before sending another message",
    );
    return;
  }

  rateLimitMap.set(senderId, now);
  await next();
};

// 3. Message analytics middleware
const analyticsMiddleware: AgentMiddleware = async (ctx, next) => {
  // Log analytics data
  console.log({
    timestamp: new Date().toISOString(),
    senderId: ctx.message.senderInboxId,
    messageLength: (ctx.message.content as string).length,
    conversationId: ctx.conversation.id,
  });

  await next();
};

// 4. Text-only filter middleware
const textOnlyMiddleware: AgentMiddleware = async (ctx, next) => {
  if (ctx.message.contentType?.typeId !== "text") {
    await ctx.conversation.send("I can only process text messages");
    return;
  }

  await next();
};

// 5. Profanity filter middleware
const profanityWords = ["spam", "scam"]; // Add your words

const profanityFilterMiddleware: AgentMiddleware = async (ctx, next) => {
  const text = (ctx.message.content as string).toLowerCase();
  const hasProfanity = profanityWords.some((word) => text.includes(word));

  if (hasProfanity) {
    await ctx.conversation.send("‚ö†Ô∏è Message contains inappropriate content");
    return;
  }

  await next();
};

// Use multiple middlewares (they run in order)
agent.use(textOnlyMiddleware);
agent.use(rateLimitMiddleware);
agent.use(authMiddleware);
agent.use(analyticsMiddleware);
agent.use(profanityFilterMiddleware);
agent.use(router.middleware());
```

### Advanced Middleware Patterns

```typescript
// Conditional middleware factory
const createConditionalMiddleware = (
  condition: (ctx: AgentContext) => boolean,
  middleware: AgentMiddleware,
): AgentMiddleware => {
  return async (ctx, next) => {
    if (condition(ctx)) {
      await middleware(ctx, next);
    } else {
      await next();
    }
  };
};

// Use conditional middleware
const adminOnlyAuth = createConditionalMiddleware(
  (ctx) => (ctx.message.content as string).startsWith("/admin"),
  authMiddleware,
);

agent.use(adminOnlyAuth);

// Error handling middleware
const errorHandlingMiddleware: AgentMiddleware = async (ctx, next) => {
  try {
    await next();
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("Middleware error:", errorMessage);
    await ctx.conversation.send("‚ùå An error occurred processing your message");
  }
};

// Context enrichment middleware
const enrichContextMiddleware: AgentMiddleware = async (ctx, next) => {
  // Add custom properties to context
  (ctx as any).timestamp = Date.now();
  (ctx as any).messageCount = await ctx.conversation
    .messages()
    .then((msgs) => msgs.length);

  await next();
};

// Feature flag middleware
const featureFlags = {
  newFeatureEnabled: true,
  betaFeatures: false,
};

const featureFlagMiddleware: AgentMiddleware = async (ctx, next) => {
  (ctx as any).features = featureFlags;
  await next();
};
```

### Creating Custom Command Routers

```typescript
// Custom router with advanced features
class AdvancedCommandRouter {
  private commands = new Map<
    string,
    {
      handler: (ctx: AgentContext) => Promise<void>;
      description: string;
      adminOnly?: boolean;
    }
  >();

  command(
    cmd: string,
    description: string,
    handler: (ctx: AgentContext) => Promise<void>,
    options?: { adminOnly?: boolean },
  ) {
    this.commands.set(cmd.toLowerCase(), {
      handler,
      description,
      ...options,
    });
    return this;
  }

  middleware(): AgentMiddleware {
    return async (ctx, next) => {
      const text = ctx.message.content as string;
      const [command] = text.split(" ");

      if (!command.startsWith("/")) {
        await next();
        return;
      }

      const commandInfo = this.commands.get(command.toLowerCase());
      if (!commandInfo) {
        await ctx.conversation.send(
          "‚ùå Unknown command. Type /help for available commands.",
        );
        return;
      }

      // Check admin permissions
      if (commandInfo.adminOnly) {
        const adminUsers = ["admin-inbox-id"];
        if (!adminUsers.includes(ctx.message.senderInboxId)) {
          await ctx.conversation.send("‚ùå Admin access required");
          return;
        }
      }

      await commandInfo.handler(ctx);
    };
  }

  getHelpText(): string {
    const commands = Array.from(this.commands.entries())
      .map(
        ([cmd, info]) =>
          `${cmd} - ${info.description}${info.adminOnly ? " (Admin only)" : ""}`,
      )
      .join("\n");

    return `Available commands:\n${commands}`;
  }
}

// Usage
const advancedRouter = new AdvancedCommandRouter();

advancedRouter
  .command("/help", "Show available commands", async (ctx) => {
    await ctx.conversation.send(advancedRouter.getHelpText());
  })
  .command(
    "/restart",
    "Restart the agent",
    async (ctx) => {
      await ctx.conversation.send("üîÑ Restarting agent...");
      // Restart logic here
    },
    { adminOnly: true },
  );

agent.use(advancedRouter.middleware());
```

### Middleware Best Practices

1. **Order matters** - Middleware runs in the order you add it
2. **Call `next()`** - Always call `next()` unless you want to stop processing
3. **Handle errors** - Use try/catch blocks in middleware
4. **Keep it focused** - Each middleware should have a single responsibility
5. **Make it reusable** - Create factory functions for configurable middleware
6. **Document behavior** - Clear comments about what each middleware does

## Building Custom Middleware

This section covers how to build your own middleware from scratch, including the architecture and implementation patterns used in the Agent SDK.

### Middleware Architecture

Middleware in the Agent SDK follows a simple but powerful pattern:

```typescript
import {
  type AgentContext,
  type AgentEventHandler,
  type AgentMiddleware,
} from "@xmtp/agent-sdk";

// Basic middleware signature
type AgentMiddleware<ContentTypes = any> = (
  ctx: AgentContext,
  next: () => Promise<void>,
) => Promise<void>;

// Event handler signature
type AgentEventHandler = (ctx: AgentContext) => Promise<void>;
```

### Step-by-Step Middleware Implementation

#### 1. Simple Function-Based Middleware

Start with the simplest approach - a function that takes context and next:

```typescript
import { type AgentMiddleware } from "@xmtp/agent-sdk";

// Simple logging middleware
const simpleLogger: AgentMiddleware = async (ctx, next) => {
  console.log(`üì® Message received: ${ctx.message.content}`);
  await next(); // Continue to next middleware
  console.log(`‚úÖ Message processed`);
};

// Use it
agent.use(simpleLogger);
```

#### 2. Configurable Middleware Factory

Create reusable middleware by using factory functions:

```typescript
// Factory function that returns configured middleware
const createLogger = (
  prefix: string,
  includeMetadata = false,
): AgentMiddleware => {
  return async (ctx, next) => {
    const message = includeMetadata
      ? `${prefix} [${ctx.message.senderInboxId}]: ${ctx.message.content}`
      : `${prefix} ${ctx.message.content}`;

    console.log(message);
    await next();
  };
};

// Use with different configurations
agent.use(createLogger("üîç DEBUG:", true));
agent.use(createLogger("üìù LOG:", false));
```

#### 3. Class-Based Middleware with State

For complex middleware that needs to maintain state:

```typescript
class RateLimitMiddleware {
  private limits = new Map<string, { count: number; resetTime: number }>();
  private maxRequests: number;
  private windowMs: number;

  constructor(maxRequests = 10, windowMs = 60000) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }

  middleware(): AgentMiddleware {
    return async (ctx, next) => {
      const senderId = ctx.message.senderInboxId;
      const now = Date.now();

      // Get or create limit info for this sender
      let limitInfo = this.limits.get(senderId);
      if (!limitInfo || now > limitInfo.resetTime) {
        limitInfo = { count: 0, resetTime: now + this.windowMs };
        this.limits.set(senderId, limitInfo);
      }

      // Check if limit exceeded
      if (limitInfo.count >= this.maxRequests) {
        const resetIn = Math.ceil((limitInfo.resetTime - now) / 1000);
        await ctx.conversation.send(
          `‚è∞ Rate limit exceeded. Try again in ${resetIn} seconds.`,
        );
        return; // Don't call next() to stop processing
      }

      // Increment counter and continue
      limitInfo.count++;
      await next();
    };
  }

  // Helper method to check current limits
  getStats(senderId: string): { count: number; remaining: number } {
    const limitInfo = this.limits.get(senderId);
    if (!limitInfo || Date.now() > limitInfo.resetTime) {
      return { count: 0, remaining: this.maxRequests };
    }
    return {
      count: limitInfo.count,
      remaining: Math.max(0, this.maxRequests - limitInfo.count),
    };
  }
}

// Usage
const rateLimiter = new RateLimitMiddleware(5, 30000); // 5 requests per 30 seconds
agent.use(rateLimiter.middleware());
```

#### 4. Advanced Command Router Implementation

Here's how to build a sophisticated command router like the one in the Agent SDK:

```typescript
import {
  isText,
  type AgentContext,
  type AgentEventHandler,
  type AgentMiddleware,
} from "@xmtp/agent-sdk";

// Utility to check if message is text

export class CommandRouter<ContentTypes = any> {
  private commandMap = new Map<string, AgentEventHandler>();
  private defaultHandler: AgentEventHandler | null = null;

  /**
   * Register a command handler
   * @param command - Command string (must start with "/")
   * @param handler - Function to handle the command
   */
  command(command: string, handler: AgentEventHandler): this {
    if (!command.startsWith("/")) {
      throw new Error('Command must start with "/"');
    }
    this.commandMap.set(command.toLowerCase(), handler);
    return this; // Return this for method chaining
  }

  /**
   * Set a default handler for unrecognized commands
   * @param handler - Default handler function
   */
  default(handler: AgentEventHandler): this {
    this.defaultHandler = handler;
    return this;
  }

  /**
   * Handle a message and determine if it was processed
   * @param ctx - Agent context
   * @returns true if message was handled, false otherwise
   */
  async handle(ctx: AgentContext): Promise<boolean> {
    // Only process text messages
    if (!isText(ctx.message)) {
      return false;
    }

    const messageText = ctx.message.content;
    const parts = messageText.split(" ");
    const command = parts[0].toLowerCase();

    // Check if this is a command message
    if (command.startsWith("/")) {
      const handler = this.commandMap.get(command);
      if (handler) {
        await handler(ctx);
        return true;
      }
    }

    // If no command matched and there's a default handler, use it
    if (this.defaultHandler) {
      await this.defaultHandler(ctx);
      return true;
    }

    return false;
  }

  /**
   * Create middleware function that can be used with agent.use()
   */
  middleware(): AgentMiddleware<ContentTypes> {
    return async (ctx, next) => {
      const handled = await this.handle(ctx);
      if (!handled) {
        await next(); // Continue to next middleware if not handled
      }
    };
  }

  /**
   * Get list of registered commands (useful for help messages)
   */
  getCommands(): string[] {
    return Array.from(this.commandMap.keys());
  }
}

// Usage example with method chaining
const router = new CommandRouter();

router
  .command("/help", async (ctx) => {
    const commands = router.getCommands().join(", ");
    await ctx.conversation.send(`Available commands: ${commands}`);
  })
  .command("/ping", async (ctx) => {
    await ctx.conversation.send("üèì Pong!");
  })
  .command("/time", async (ctx) => {
    await ctx.conversation.send(`‚è∞ Current time: ${new Date().toISOString()}`);
  })
  .default(async (ctx) => {
    await ctx.conversation.send(
      "‚ùì Unknown command. Type /help for available commands.",
    );
  });

agent.use(router.middleware());
```

#### 5. Middleware with Dependency Injection

For complex applications, you might want middleware that depends on external services:

```typescript
interface DatabaseService {
  logMessage(senderId: string, content: string): Promise<void>;
  getUserPreferences(
    senderId: string,
  ): Promise<{ language: string; timezone: string }>;
}

interface NotificationService {
  sendAlert(message: string): Promise<void>;
}

class ServiceAwareMiddleware {
  constructor(
    private db: DatabaseService,
    private notifications: NotificationService,
  ) {}

  middleware(): AgentMiddleware {
    return async (ctx, next) => {
      try {
        // Log the message
        await this.db.logMessage(
          ctx.message.senderInboxId,
          ctx.message.content as string,
        );

        // Get user preferences and add to context
        const preferences = await this.db.getUserPreferences(
          ctx.message.senderInboxId,
        );
        (ctx as any).userPreferences = preferences;

        await next();
      } catch (error: unknown) {
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        await this.notifications.sendAlert(`Middleware error: ${errorMessage}`);

        // Still continue processing
        await next();
      }
    };
  }
}

// Usage with dependency injection
const dbService: DatabaseService = new MyDatabaseService();
const notificationService: NotificationService = new MyNotificationService();

const serviceMiddleware = new ServiceAwareMiddleware(
  dbService,
  notificationService,
);
agent.use(serviceMiddleware.middleware());
```

#### 6. Middleware Composition Patterns

Combine multiple middleware into reusable compositions:

```typescript
// Middleware composer utility
class MiddlewareComposer {
  private middlewares: AgentMiddleware[] = [];

  add(middleware: AgentMiddleware): this {
    this.middlewares.push(middleware);
    return this;
  }

  compose(): AgentMiddleware {
    return async (ctx, next) => {
      let index = 0;

      const dispatch = async (): Promise<void> => {
        if (index >= this.middlewares.length) {
          await next();
          return;
        }

        const middleware = this.middlewares[index++];
        await middleware(ctx, dispatch);
      };

      await dispatch();
    };
  }
}

// Pre-built middleware combinations
const createSecureMiddleware = () => {
  return new MiddlewareComposer()
    .add(rateLimitMiddleware)
    .add(authMiddleware)
    .add(textOnlyMiddleware)
    .compose();
};

const createLoggingMiddleware = () => {
  return new MiddlewareComposer()
    .add(analyticsMiddleware)
    .add(createLogger("üîç", true))
    .compose();
};

// Use composed middleware
agent.use(createSecureMiddleware());
agent.use(createLoggingMiddleware());
```

### Middleware Testing Patterns

Test your middleware in isolation:

```typescript
// Mock context for testing
const createMockContext = (
  content: string,
  senderInboxId = "test-sender",
): AgentContext =>
  ({
    message: {
      content,
      senderInboxId,
      contentType: { typeId: "text" },
    },
    conversation: {
      send: jest.fn(),
      id: "test-conversation",
    },
    client: {},
  }) as any;

// Test middleware
describe("RateLimitMiddleware", () => {
  it("should allow messages under limit", async () => {
    const middleware = new RateLimitMiddleware(2, 60000);
    const ctx = createMockContext("test message");
    const next = jest.fn();

    await middleware.middleware()(ctx, next);

    expect(next).toHaveBeenCalled();
    expect(ctx.conversation.send).not.toHaveBeenCalled();
  });

  it("should block messages over limit", async () => {
    const middleware = new RateLimitMiddleware(1, 60000);
    const ctx = createMockContext("test message");
    const next = jest.fn();

    // First message should pass
    await middleware.middleware()(ctx, next);
    expect(next).toHaveBeenCalledTimes(1);

    // Second message should be blocked
    next.mockClear();
    await middleware.middleware()(ctx, next);
    expect(next).not.toHaveBeenCalled();
    expect(ctx.conversation.send).toHaveBeenCalledWith(
      expect.stringContaining("Rate limit exceeded"),
    );
  });
});
```

### Middleware Performance Considerations

1. **Async Operations**: Always use `await` with async operations
2. **Error Handling**: Wrap middleware logic in try/catch blocks
3. **Memory Management**: Clean up resources and avoid memory leaks in stateful middleware
4. **Performance Monitoring**: Add timing and metrics to critical middleware

```typescript
const performanceMiddleware: AgentMiddleware = async (ctx, next) => {
  const start = Date.now();

  try {
    await next();
  } finally {
    const duration = Date.now() - start;
    console.log(`‚è±Ô∏è Message processing took ${duration}ms`);

    // Alert on slow processing
    if (duration > 5000) {
      console.warn(`üêå Slow message processing: ${duration}ms`);
    }
  }
};
```

### 3. Built-in Filters

Instead of manually checking every incoming message, use simple, reusable filters to handle specific message types efficiently.

## Filters Reference

The Agent SDK provides a comprehensive filter system for message processing. Filters can be combined using logical operators to create complex filtering logic.

### Basic Filters

```typescript
import { filter, withFilter } from "@xmtp/agent-sdk";

// Pre-configured filters (no function call needed)
filter.notFromSelf; // Exclude messages from the agent itself
filter.fromSelf; // Include only messages from the agent itself
filter.textOnly; // Include only text messages
```

### Factory Function Filters

```typescript
// Messages from specific senders
filter.fromSender("inbox-id-123"); // Single sender
filter.fromSender(["inbox-1", "inbox-2", "inbox-3"]); // Multiple senders

// Text content matching
filter.startsWith("@agent"); // Messages starting with "@agent"
filter.startsWith("/help"); // Command-style messages
filter.startsWith("!"); // Messages starting with "!"
```

### Logical Combinators

```typescript
// AND - All filters must pass
const strictFilter = filter.and(
  filter.notFromSelf,
  filter.textOnly,
  filter.startsWith("/"),
);

// OR - At least one filter must pass
const flexibleFilter = filter.or(
  filter.startsWith("@agent"),
  filter.startsWith("/help"),
  filter.fromSender("admin-inbox-id"),
);

// NOT - Invert any filter
const notTextFilter = filter.not(filter.textOnly);
const notFromAdmin = filter.not(filter.fromSender("admin-inbox-id"));
```

### Practical Filter Examples

```typescript
// 1. Command handler - only process commands from users
const commandFilter = filter.and(
  filter.notFromSelf,
  filter.textOnly,
  filter.startsWith("/"),
);

agent.on(
  "message",
  withFilter(commandFilter, async (ctx) => {
    const command = ctx.message.content as string;
    console.log(`Processing command: ${command}`);
    // Handle commands like /help, /status, etc.
  }),
);

// 2. Admin-only messages
const adminFilter = filter.and(
  filter.notFromSelf,
  filter.fromSender(["admin-inbox-1", "admin-inbox-2"]),
);

agent.on(
  "message",
  withFilter(adminFilter, async (ctx) => {
    await ctx.conversation.send("Admin command received! üîß");
  }),
);

// 3. Public conversation filter (exclude self and commands)
const publicFilter = filter.and(
  filter.notFromSelf,
  filter.textOnly,
  filter.not(filter.startsWith("/")),
);

agent.on(
  "message",
  withFilter(publicFilter, async (ctx) => {
    // Process regular conversation messages
    await ctx.conversation.send("Thanks for your message! üí¨");
  }),
);

// 4. Multi-trigger filter
const helpTriggers = filter.or(
  filter.startsWith("/help"),
  filter.startsWith("help"),
  filter.startsWith("@agent help"),
);

agent.on(
  "message",
  withFilter(helpTriggers, async (ctx) => {
    await ctx.conversation.send("How can I help you? ü§ñ");
  }),
);

// 5. VIP user filter
const vipUsers = ["vip-inbox-1", "vip-inbox-2"];
const vipFilter = filter.and(filter.notFromSelf, filter.fromSender(vipUsers));

agent.on(
  "message",
  withFilter(vipFilter, async (ctx) => {
    await ctx.conversation.send(
      "Hello VIP user! Priority support activated. ‚≠ê",
    );
  }),
);

// 6. Debug filter - only self messages for testing
const debugFilter = filter.and(filter.fromSelf, filter.startsWith("debug:"));

agent.on(
  "message",
  withFilter(debugFilter, async (ctx) => {
    console.log("Debug message received:", ctx.message.content);
  }),
);
```

### Custom Filter Creation

You can create your own custom filters by implementing the `MessageFilter` type:

```typescript
import type { MessageFilter } from "@xmtp/agent-sdk";

// Custom filter for messages containing specific keywords
const containsKeyword = (keyword: string): MessageFilter<any> => {
  return (message, client) => {
    if (message.contentType?.sameAs(ContentTypeText)) {
      const text = message.content as string;
      return text.toLowerCase().includes(keyword.toLowerCase());
    }
    return false;
  };
};

// Custom filter for message length
const minLength = (length: number): MessageFilter<any> => {
  return (message, client) => {
    if (message.contentType?.sameAs(ContentTypeText)) {
      const text = message.content as string;
      return text.length >= length;
    }
    return false;
  };
};

// Use custom filters
const customFilter = filter.and(
  filter.notFromSelf,
  containsKeyword("urgent"),
  minLength(10),
);

agent.on(
  "message",
  withFilter(customFilter, async (ctx) => {
    await ctx.conversation.send("Urgent message received! üö®");
  }),
);
```

### Filter Shortcuts

For convenience, you can import `f` as a shorter alias:

```typescript
import { f, withFilter } from "@xmtp/agent-sdk";

// Same functionality, shorter syntax
const quickFilter = f.and(f.notFromSelf, f.textOnly);
```

## Building Custom Filters

This section covers how to create your own custom filters from scratch, including the architecture and implementation patterns used in the Agent SDK's filter system.

### Filter Architecture

Filters in the Agent SDK follow a simple functional pattern:

```typescript
import type { Client, DecodedMessage } from "@xmtp/agent-sdk";

/**
 * Function type for filtering messages based on content and client state.
 */
export type MessageFilter<ContentTypes> = (
  message: DecodedMessage,
  client: Client<ContentTypes>,
) => boolean;
```

### Step-by-Step Filter Implementation

#### 1. Simple Content-Based Filters

Start with filters that examine message content:

```typescript
import type { MessageFilter } from "@xmtp/agent-sdk";
import { ContentTypeText } from "@xmtp/content-type-text";

/**
 * Filter for messages containing specific keywords
 */
function containsKeyword<ContentTypes>(
  keyword: string,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    if (message.contentType?.sameAs(ContentTypeText)) {
      const text = message.content as string;
      return text.toLowerCase().includes(keyword.toLowerCase());
    }
    return false;
  };
}

/**
 * Filter for messages with minimum length
 */
function minLength<ContentTypes>(length: number): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    if (message.contentType?.sameAs(ContentTypeText)) {
      const text = message.content as string;
      return text.length >= length;
    }
    return false;
  };
}

/**
 * Filter for messages matching regex pattern
 */
function matchesPattern<ContentTypes>(
  pattern: RegExp,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    if (message.contentType?.sameAs(ContentTypeText)) {
      const text = message.content as string;
      return pattern.test(text);
    }
    return false;
  };
}

// Usage examples
const urgentFilter = containsKeyword("urgent");
const longMessageFilter = minLength(100);
const emailFilter = matchesPattern(
  /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/,
);
```

#### 2. Sender-Based Filters

Create filters based on message sender information:

```typescript
/**
 * Filter for messages from specific senders
 */
function fromSender<ContentTypes>(
  senderInboxId: string | string[],
): MessageFilter<ContentTypes> {
  const senderIds = Array.isArray(senderInboxId)
    ? senderInboxId
    : [senderInboxId];

  return (message: DecodedMessage) => {
    return senderIds.includes(message.senderInboxId);
  };
}

/**
 * Filter for messages from verified senders (example with external verification)
 */
function fromVerifiedSender<ContentTypes>(
  verifiedSenders: Set<string>,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return verifiedSenders.has(message.senderInboxId);
  };
}

/**
 * Filter for messages excluding blocked senders
 */
function notFromBlocked<ContentTypes>(
  blockedSenders: string[],
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return !blockedSenders.includes(message.senderInboxId);
  };
}

// Usage
const adminFilter = fromSender(["admin-1", "admin-2"]);
const verifiedUsers = new Set(["verified-user-1", "verified-user-2"]);
const verifiedFilter = fromVerifiedSender(verifiedUsers);
const notBlockedFilter = notFromBlocked(["spam-user", "blocked-user"]);
```

#### 3. Time-Based Filters

Create filters that consider message timing:

```typescript
/**
 * Filter for recent messages (within specified milliseconds)
 */
function isRecent<ContentTypes>(maxAgeMs: number): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    const messageTime = message.sent?.getTime() || 0;
    const now = Date.now();
    return now - messageTime <= maxAgeMs;
  };
}

/**
 * Filter for messages sent during business hours
 */
function duringBusinessHours<ContentTypes>(
  timezone = "UTC",
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    if (!message.sent) return false;

    const messageTime = new Date(
      message.sent.toLocaleString("en-US", { timeZone: timezone }),
    );
    const hour = messageTime.getHours();
    const day = messageTime.getDay();

    // Monday-Friday, 9 AM - 5 PM
    return day >= 1 && day <= 5 && hour >= 9 && hour < 17;
  };
}

/**
 * Filter for messages sent on weekends
 */
function onWeekend<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    if (!message.sent) return false;
    const day = message.sent.getDay();
    return day === 0 || day === 6; // Sunday or Saturday
  };
}

// Usage
const recentFilter = isRecent(5 * 60 * 1000); // Last 5 minutes
const businessHoursFilter = duringBusinessHours("America/New_York");
const weekendFilter = onWeekend();
```

#### 4. Content Type Filters

Create filters for different message content types:

```typescript
import { ContentTypeAttachment } from "@xmtp/content-type-remote-attachment";
import { ContentTypeText } from "@xmtp/content-type-text";

/**
 * Filter for text-only messages
 */
function textOnly<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return !!message.contentType?.sameAs(ContentTypeText);
  };
}

/**
 * Filter for attachment messages
 */
function hasAttachment<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return !!message.contentType?.sameAs(ContentTypeAttachment);
  };
}

/**
 * Filter for specific content types
 */
function hasContentType<ContentTypes>(
  contentType: any,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return !!message.contentType?.sameAs(contentType);
  };
}

/**
 * Filter for custom content types by type ID
 */
function hasContentTypeId<ContentTypes>(
  typeId: string,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return message.contentType?.typeId === typeId;
  };
}

// Usage
const textFilter = textOnly();
const attachmentFilter = hasAttachment();
const replyFilter = hasContentTypeId("reply");
const actionFilter = hasContentTypeId("intent");
```

#### 5. Advanced Logical Combinators

Build complex filters using logical operations:

```typescript
/**
 * Creates a filter that requires all provided filters to pass
 */
function and<ContentTypes>(
  ...filters: MessageFilter<ContentTypes>[]
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage, client: Client<ContentTypes>) => {
    for (const filter of filters) {
      const result = filter(message, client);
      if (!result) return false;
    }
    return true;
  };
}

/**
 * Creates a filter that requires at least one provided filter to pass
 */
function or<ContentTypes>(
  ...filters: MessageFilter<ContentTypes>[]
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage, client: Client<ContentTypes>) => {
    for (const filter of filters) {
      const result = filter(message, client);
      if (result) return true;
    }
    return false;
  };
}

/**
 * Creates a filter that inverts another filter
 */
function not<ContentTypes>(
  filter: MessageFilter<ContentTypes>,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage, client: Client<ContentTypes>) => {
    return !filter(message, client);
  };
}

/**
 * Creates a conditional filter that only applies when condition is met
 */
function when<ContentTypes>(
  condition: MessageFilter<ContentTypes>,
  thenFilter: MessageFilter<ContentTypes>,
  elseFilter?: MessageFilter<ContentTypes>,
): MessageFilter<ContentTypes> {
  return (message: DecodedMessage, client: Client<ContentTypes>) => {
    if (condition(message, client)) {
      return thenFilter(message, client);
    }
    return elseFilter ? elseFilter(message, client) : true;
  };
}

// Complex filter combinations
const complexFilter = and(
  not(fromSelf()),
  textOnly(),
  or(
    containsKeyword("urgent"),
    fromSender(["admin-1", "admin-2"]),
    and(duringBusinessHours(), minLength(10)),
  ),
);
```

#### 6. Stateful Filters

Create filters that maintain state across messages:

```typescript
/**
 * Filter that tracks message frequency per sender
 */
function rateLimited<ContentTypes>(
  maxMessages: number,
  windowMs: number,
): MessageFilter<ContentTypes> {
  const senderCounts = new Map<string, { count: number; resetTime: number }>();

  return (message: DecodedMessage) => {
    const senderId = message.senderInboxId;
    const now = Date.now();

    let senderData = senderCounts.get(senderId);
    if (!senderData || now > senderData.resetTime) {
      senderData = { count: 0, resetTime: now + windowMs };
      senderCounts.set(senderId, senderData);
    }

    senderData.count++;
    return senderData.count <= maxMessages;
  };
}

/**
 * Filter that remembers previously seen messages
 */
function notDuplicate<ContentTypes>(): MessageFilter<ContentTypes> {
  const seenMessages = new Set<string>();

  return (message: DecodedMessage) => {
    const messageKey = `${message.senderInboxId}-${message.content}`;
    if (seenMessages.has(messageKey)) {
      return false;
    }
    seenMessages.add(messageKey);
    return true;
  };
}

/**
 * Filter with conversation history awareness
 */
function conversationAware<ContentTypes>(
  minMessages: number,
): MessageFilter<ContentTypes> {
  const conversationCounts = new Map<string, number>();

  return (message: DecodedMessage) => {
    const conversationId = message.conversation?.id || "unknown";
    const currentCount = conversationCounts.get(conversationId) || 0;
    conversationCounts.set(conversationId, currentCount + 1);
    return currentCount >= minMessages;
  };
}

// Usage
const rateLimitFilter = rateLimited(5, 60000); // 5 messages per minute
const noDuplicatesFilter = notDuplicate();
const establishedConversationFilter = conversationAware(3);
```

#### 7. Context-Aware Filters

Create filters that use client state and context:

```typescript
/**
 * Filter that excludes messages from self
 */
function notFromSelf<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage, client: Client<ContentTypes>) => {
    return message.senderInboxId !== client.inboxId;
  };
}

/**
 * Filter for messages from contacts
 */
function fromContacts<ContentTypes>(): MessageFilter<ContentTypes> {
  return async (message: DecodedMessage, client: Client<ContentTypes>) => {
    // This would require async support in the filter system
    // For now, we'll use a synchronous approach with pre-loaded contacts
    const contacts = await client.contacts.list();
    const contactIds = contacts.map((c) => c.inboxId);
    return contactIds.includes(message.senderInboxId);
  };
}

/**
 * Filter for messages in specific conversation types
 */
function inGroupConversation<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return message.conversation?.conversationType === "group";
  };
}

/**
 * Filter for direct messages only
 */
function directMessagesOnly<ContentTypes>(): MessageFilter<ContentTypes> {
  return (message: DecodedMessage) => {
    return message.conversation?.conversationType === "dm";
  };
}

// Usage
const notSelfFilter = notFromSelf();
const groupFilter = inGroupConversation();
const dmFilter = directMessagesOnly();
```

### Complete Filter System Implementation

Here's how to build a complete custom filter system:

```typescript
import type { AgentContext, Client, DecodedMessage } from "@xmtp/agent-sdk";
import { ContentTypeText } from "@xmtp/content-type-text";

/**
 * Function type for filtering messages
 */
export type MessageFilter<ContentTypes> = (
  message: DecodedMessage,
  client: Client<ContentTypes>,
) => boolean;

/**
 * Utility function to get text content safely
 */
function getTextContent(message: DecodedMessage): string | null {
  if (message.contentType?.sameAs(ContentTypeText)) {
    return message.content as string;
  }
  return null;
}

/**
 * Pre-configured filter instances and factory functions
 */
export const customFilter = {
  // Basic filters
  notFromSelf: notFromSelf(),
  fromSelf: fromSelf(),
  textOnly: textOnly(),

  // Factory functions
  fromSender,
  startsWith,
  containsKeyword,
  minLength,
  maxLength: (length: number) => (message: DecodedMessage) => {
    const text = getTextContent(message);
    return !!(text && text.length <= length);
  },
  matchesPattern,
  isRecent,
  duringBusinessHours,
  onWeekend,
  hasAttachment,
  hasContentType,
  hasContentTypeId,

  // Stateful filters
  rateLimited,
  notDuplicate,
  conversationAware,

  // Combinators
  and,
  or,
  not,
  when,
};

/**
 * Enhanced withFilter that supports async filters
 */
export const withCustomFilter =
  <ContentTypes>(
    filter: MessageFilter<ContentTypes>,
    listener: (ctx: AgentContext<ContentTypes>) => void | Promise<void>,
  ) =>
  async (ctx: AgentContext<ContentTypes>) => {
    if (filter(ctx.message, ctx.client)) {
      await listener(ctx);
    }
  };

// Usage examples
const complexBusinessLogic = customFilter.and(
  customFilter.notFromSelf,
  customFilter.textOnly,
  customFilter.or(
    customFilter.fromSender(["admin-1", "admin-2"]),
    customFilter.and(
      customFilter.containsKeyword("urgent"),
      customFilter.duringBusinessHours("America/New_York"),
    ),
    customFilter.and(
      customFilter.minLength(50),
      customFilter.not(customFilter.containsKeyword("spam")),
    ),
  ),
);

// Use in agent
agent.on(
  "message",
  withCustomFilter(complexBusinessLogic, async (ctx) => {
    await ctx.conversation.send("Processing your important message!");
  }),
);
```

### Filter Testing Patterns

Test your custom filters thoroughly:

```typescript
// Mock message for testing
const createMockMessage = (
  content: string,
  senderInboxId = "test-sender",
  sent = new Date(),
): DecodedMessage =>
  ({
    content,
    senderInboxId,
    sent,
    contentType: {
      sameAs: (type: any) => type === ContentTypeText,
      typeId: "text",
    },
    conversation: { id: "test-conversation", conversationType: "dm" },
  }) as any;

// Mock client for testing
const createMockClient = (inboxId = "agent-inbox"): Client<any> =>
  ({
    inboxId,
    contacts: { list: async () => [] },
  }) as any;

// Test filters
describe("Custom Filters", () => {
  describe("containsKeyword", () => {
    it("should match messages with keyword", () => {
      const filter = containsKeyword("urgent");
      const message = createMockMessage("This is urgent!");
      const client = createMockClient();

      expect(filter(message, client)).toBe(true);
    });

    it("should be case insensitive", () => {
      const filter = containsKeyword("URGENT");
      const message = createMockMessage("This is urgent!");
      const client = createMockClient();

      expect(filter(message, client)).toBe(true);
    });
  });

  describe("rateLimited", () => {
    it("should allow messages under limit", () => {
      const filter = rateLimited(2, 60000);
      const message1 = createMockMessage("Message 1", "sender-1");
      const message2 = createMockMessage("Message 2", "sender-1");
      const client = createMockClient();

      expect(filter(message1, client)).toBe(true);
      expect(filter(message2, client)).toBe(true);
    });

    it("should block messages over limit", () => {
      const filter = rateLimited(1, 60000);
      const message1 = createMockMessage("Message 1", "sender-1");
      const message2 = createMockMessage("Message 2", "sender-1");
      const client = createMockClient();

      expect(filter(message1, client)).toBe(true);
      expect(filter(message2, client)).toBe(false);
    });
  });
});
```

### Filter Performance Best Practices

1. **Early Exit**: Place the most selective filters first in `and()` combinations
2. **Cache Results**: For expensive operations, cache results when possible
3. **Minimize State**: Keep stateful filters lightweight
4. **Memory Management**: Clean up old entries in stateful filters

```typescript
// Optimized filter with cleanup
function optimizedRateLimit<ContentTypes>(
  maxMessages: number,
  windowMs: number,
): MessageFilter<ContentTypes> {
  const senderCounts = new Map<string, { count: number; resetTime: number }>();

  // Cleanup old entries periodically
  setInterval(() => {
    const now = Date.now();
    for (const [senderId, data] of senderCounts.entries()) {
      if (now > data.resetTime) {
        senderCounts.delete(senderId);
      }
    }
  }, windowMs);

  return (message: DecodedMessage) => {
    const senderId = message.senderInboxId;
    const now = Date.now();

    let senderData = senderCounts.get(senderId);
    if (!senderData || now > senderData.resetTime) {
      senderData = { count: 0, resetTime: now + windowMs };
      senderCounts.set(senderId, senderData);
    }

    senderData.count++;
    return senderData.count <= maxMessages;
  };
}
```

### 4. Rich Context

Every message handler receives an AgentContext with helpful properties and methods for easy interaction.

## Available Utilities

The Agent SDK provides several utility functions:

```typescript
import { createSigner, createUser, getTestUrl } from "@xmtp/agent-sdk";

// Create a local user + signer (for testing)
const user = createUser();
const signer = createSigner(user);

// Get a test URL for easy testing
const testUrl = getTestUrl(agent);
```

## FAQ (Quick Hits)

| Question                               | Answer                                                     |
| -------------------------------------- | ---------------------------------------------------------- |
| Does middleware run for every message? | Yes, in the order added.                                   |
| How do I reject a message early?       | Don't call `next()` in middleware.                         |
| How do I filter messages?              | Use `withFilter(...)` around an event listener.            |
| Can I send custom content types?       | Yes, register codecs during agent creation.                |
| How do I handle action button clicks?  | Listen for messages with `contentType.typeId === "intent"` |

## Best Practices

1. **Always use environment variables** for configuration with `process.loadEnvFile(".env")`
2. **Use filters** to avoid processing irrelevant messages
3. **Handle errors gracefully** with proper try/catch blocks
4. **Log important events** for debugging and monitoring
5. **Use middleware** for cross-cutting concerns
6. **Register codecs** during agent creation for custom content types
7. **Test your agent** using the provided test URL utilities
