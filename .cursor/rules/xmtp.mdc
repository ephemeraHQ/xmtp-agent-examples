---
alwaysApply: false
---

# Writing XMTP Agents

This SDK is based on familiar Node.js patterns: you register event listeners, compose middleware, and extend behavior just like you would in frameworks such as [Express](https://expressjs.com/). This makes it easy to bring existing JavaScript and TypeScript skills into building conversational agents.

## Installation

Choose your package manager:

```bash
# No other libraries should be needed
npm/pnpm/yarn install @xmtp/agent-sdk
```

## Quick Start

```ts
import { Agent, createSigner, createUser, getTestUrl } from "@xmtp/agent-sdk";

// 1. Create a local user + signer (you can plug in your own wallet signer)
const user = createUser();
const signer = createSigner(user);

// 2. Spin up the agent
const agent = await Agent.create(signer, {
  env: "production", // or 'production'
});

// 3. Respond to text messages
agent.on("text", async (ctx) => {
  const messageContent = ctx.message.content;
  const senderAddress = await ctx.getSenderAddress();
  console.log(`Received message: ${messageContent} by ${senderAddress}`);
  await ctx.conversation.send("gm");
});

// 4. Log when we're ready
agent.on("start", () => {
  console.log(`Waiting for messages...`);
  console.log(`Address: ${agent.client.accountIdentifier?.identifier}`);
  console.log(`ðŸ”—${getTestUrl(agent)}`);
});

await agent.start();
```

## Environment Variables

The XMTP Agent SDK allows you to use environment variables (`process.env`) for easier configuration without modifying code. Simply set the following variables and call `Agent.createFromEnv()`:

**Available Variables:**

| Variable                 | Purpose                                                                                                                      | Example                                 |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| `XMTP_WALLET_KEY`        | [Private key for wallet](https://docs.xmtp.org/inboxes/core-messaging/create-a-signer)                                       | `XMTP_WALLET_KEY=0x1234...abcd`         |
| `XMTP_ENV`               | [Network environment](https://docs.xmtp.org/agents/core-messaging/create-a-client#xmtp-network-environments)                 | `XMTP_ENV=dev` or `XMTP_ENV=production` |
| `XMTP_DB_ENCRYPTION_KEY` | [Database encryption key](https://docs.xmtp.org/agents/core-messaging/create-a-client#keep-the-database-encryption-key-safe) | `XMTP_DB_ENCRYPTION_KEY=0xabcd...1234`  |

Using the environment variables, you can setup your agent in just a few lines of code:

```ts
// Load variables from .env file
process.loadEnvFile(".env");

// Create agent using environment variables
const agent = await Agent.createFromEnv();
```

## Core Concepts

### 1. Eventâ€‘Driven Architecture

Subscribe only to what you need using Nodeâ€™s `EventEmitter` interface. Events you can listen for:

```ts
// Handle different message types
agent.on("text", async (ctx) => {
  console.log(`Text message: ${ctx.text}`);
});

agent.on("reaction", async (ctx) => {
  console.log(`Reaction: ${ctx.message.content}`);
});

agent.on("reply", async (ctx) => {
  console.log(`Reply to: ${ctx.message.content.reference}`);
});

// Handle new conversations
agent.on("dm", async (ctx) => {
  await ctx.conversation.send("Welcome to our DM!");
});

agent.on("group", async (ctx) => {
  await ctx.conversation.send("Hello group!");
});

// Handle uncaught errors
agent.on("unhandledError", (error) => {
  console.error("Agent error", error);
});
```

### 2. Middleware Support

Extend your agent with custom business logic using middlewares. Compose cross-cutting behavior like routing, telemetry, rate limiting, analytics, and feature flags, or plug in your own.

**Example**

```ts
import { CommandRouter } from "@xmtp/agent-sdk";

const router = new CommandRouter();

router.command("/version", async (ctx) => {
  await ctx.conversation.send(`v${process.env.npm_package_version}`);
});

agent.use(router.middleware());
```

### 3. Builtâ€‘in Filters

Instead of manually checking every incoming message, you can compose simple, reusable filters that make intent clear.

**Example**

```ts
import { filter, withFilter } from "@xmtp/agent-sdk";

// Using filter in message handler
agent.on(
  "text",
  withFilter(filter.startsWith("@agent"), async (ctx) => {
    await ctx.conversation.send("How can I help you?");
  }),
);

// Combination of filters
const combined = filter.and(filter.notFromSelf, filter.isText);

agent.on(
  "text",
  withFilter(combined, async (ctx) => {
    await ctx.conversation.send("You sent a text message âœ…");
  }),
);
```

For convenience, the `filter` object can also be imported as `f`:

```ts
// You can import either name:
import { f, filter } from "@xmtp/agent-sdk";

// Both work the same way:
const longVersion = filter.and(filter.notFromSelf, filter.isText);
const shortVersion = f.and(f.notFromSelf, f.isText);
```

**Example**

```ts
agent.on("text", async (ctx) => {
  await ctx.sendTextReply("Reply using helper âœ¨");
});
```

## Adding Custom Content Types

Pass `codecs` when creating your agent to extend supported content:

```ts
const agent = await Agent.create(signer, {
  env: "dev",
  codecs: [new MyContentType()],
});
```

## Prompt example to code an agent

Prompt: "Lets create a multiplier agent that gets a number and returns its 2x multiple (use claude max)"

Code:

```ts
import fs from "fs";
import { Agent, createSigner, createUser, getTestUrl } from "@xmtp/agent-sdk";

process.loadEnvFile(".env");

const agent = await Agent.create(
  createSigner(createUser(process.env.XMTP_WALLET_KEY as `0x${string}`)),
  {
    env: process.env.XMTP_ENV as "local" | "dev" | "production",
  },
);

agent.on("text", async (ctx) => {
  const messageContent = ctx.message.content.trim();
  console.log("New message received: ", messageContent);

  try {
    // Parse the message to extract two numbers
    const result = parseAndMultiply(messageContent);
    await ctx.conversation.send(result);
  } catch (error) {
    console.error("Error processing message:", error);
    await ctx.conversation.send(
      "Please send two numbers separated by space, comma, or 'x'. Examples: '5 3', '5,3', '5 x 3', 'multiply 5 and 3'",
    );
  }
});

agent.on("dm", (ctx) => {
  console.log("New conversation created with id: ", ctx.conversation.id);
});

agent.on("start", () => {
  console.log(`Multiplication Agent is running...`);
  console.log(`Address: ${agent.client.accountIdentifier?.identifier}`);
  console.log(`ðŸ”—${getTestUrl(agent)}`);
  console.log(`Send a number to multiply!`);
});

await agent.start();
function parseAndMultiply(message: string): string {
  // Extract the first number from the message
  const match = message.match(/(\d+(?:\.\d+)?)/);

  if (!match) {
    throw new Error("Could not find a number to multiply");
  }

  const number = parseFloat(match[1]);
  const result = number * 2;
  return `${number} Ã— 2 = ${result}`;
}
```

## Identifiers Reference

When working with XMTP, you'll encounter several types of identifiers:

### Ethereum Addresses

- Format: `0x` followed by 40 hexadecimal characters
- Example: `0xfb55CB623f2aB58Da17D8696501054a2ACeD1944`
- Usage: Identifies blockchain wallets associated with XMTP users

### Private Key

- Format: `0x` followed by 64 hexadecimal characters
- Example: `0x11567776b95bdbed513330f503741e19877bf7fe73e7957bf6f0ecf3e267fdb8`
- Usage: Used to create the signer for authenticating with XMTP

### Encryption Key

- Format: 64 hexadecimal characters (without "0x" prefix)
- Example: `11973168e34839f9d31749ad77204359c5c39c404e1154eacb7f35a867ee47de`
- Usage: Used for encrypting the local database

### Inbox ID

- Format: 64 hexadecimal characters (without "0x" prefix)
- Example: `1180478fde9f6dfd4559c25f99f1a3f1505e1ad36b9c3a4dd3d5afb68c419179`
- Usage: Primary identifier for XMTP conversations

### Installation ID

- Format: 64 hexadecimal characters (without "0x" prefix)
- Example: `a83166f3ab057f28d634cc04df5587356063dba11bf7d6bcc08b21a8802f4028`
- Usage: Identifies a specific XMTP client installation
- Access via `member.installationIds` array on GroupMember objects

### Example User Credentials Set

```json
{
  "accountAddress": "0xfb55CB623f2aB58Da17D8696501054a2ACeD1944",
  "privateKey": "0x11567776b95bdbed513330f503741e19877bf7fe73e7957bf6f0ecf3e267fdb8",
  "encryptionKey": "11973168e34839f9d31749ad77204359c5c39c404e1154eacb7f35a867ee47de",
  "inboxId": "1180478fde9f6dfd4559c25f99f1a3f1505e1ad36b9c3a4dd3d5afb68c419179",
  "installationId": "a83166f3ab057f28d634cc04df5587356063dba11bf7d6bcc08b21a8802f4028"
}
```

## Working with Members

All conversations, both Groups and DMs, have a members() method that returns an array of GroupMember objects:

```typescript
// Get members from any conversation type (DM or Group)
const members = await conversation.members();

// Find a specific member
const member = members.find(
  (member) => member.inboxId.toLowerCase() === targetInboxId.toLowerCase(),
);

// Get member's Ethereum address
if (member) {
  const ethIdentifier = member.accountIdentifiers.find(
    (id) => id.identifierKind === IdentifierKind.Ethereum,
  );

  if (ethIdentifier) {
    const ethereumAddress = ethIdentifier.identifier;
    console.log(`Found Ethereum address: ${ethereumAddress}`);
  }

  // Get installation ID
  if (member.installationIds.length > 0) {
    const installationId = member.installationIds[0];
    console.log(`Found installation ID: ${installationId}`);
  }
}
```

## Working with Conversations

XMTP provides two main conversation types:

### Direct Messages (DMs)

```typescript
// Create a new DM
const dm = await client.conversations.newDm("inboxId123");

// Or create using an Ethereum address
const dmByAddress = await client.conversations.newDmWithIdentifier({
  identifier: "0x7c40611372d354799d138542e77243c284e460b2",
  identifierKind: IdentifierKind.Ethereum,
});

// Send a message
await dm.send("Hello!");

// Access peer's inbox ID
const peerInboxId = dm.peerInboxId;
```

### Groups

```typescript
// Create a new group
const group = await client.conversations.newGroup(["inboxId1", "inboxId2"], {
  groupName: "My Group",
  groupDescription: "Group description",
});

// Update group metadata
await group.updateName("New Group Name");
await group.updateDescription("Updated description");

// Manage members
await group.addMembers(["newMemberInboxId"]);
await group.removeMembers(["memberToRemoveInboxId"]);

// Manage permissions
await group.addAdmin("memberInboxId");
await group.addSuperAdmin("memberInboxId");
```

## Group Creation Options

When creating a new group, use the correct options interface:

```typescript
export declare const enum PermissionUpdateType {
  AddMember = 0,
  RemoveMember = 1,
  AddAdmin = 2,
  RemoveAdmin = 3,
  UpdateMetadata = 4,
}

export declare const enum PermissionPolicy {
  Allow = 0,
  Deny = 1,
  Admin = 2,
  SuperAdmin = 3,
  DoesNotExist = 4,
  Other = 5,
}

export interface CreateGroupOptions {
  permissions?: GroupPermissionsOptions;
  groupName?: string;
  groupImageUrlSquare?: string;
  groupDescription?: string;
  customPermissionPolicySet?: PermissionPolicySet;
  messageDisappearingSettings?: MessageDisappearingSettings;
}
```

Example usage:

```typescript
// Create a group with some initial settings
const group = await client.conversations.newGroup([inboxId1, inboxId2], {
  groupName: "Project Discussion",
  groupDescription: "A group for our project collaboration",
  groupImageUrlSquare: "https://example.com/image.jpg",
});

// Update group settings later
await group.updateName("Updated Project Name");
await group.updateDescription("Our awesome project discussion");
await group.updateImageUrl("https://example.com/new-image.jpg");
```

## Fetching Messages

There are two ways to retrieve messages from conversations:

### 1. Streaming Messages (Recommended for Agents)

Stream all messages to process them in real-time:

```typescript
const stream = await client.conversations.streamAllMessages();
for await (const message of stream) {
  // Process each message as it arrives
  console.log(`Received message: ${message.content as string}`);
}
```

### 2. Polling Messages

Retrieve all messages at once from the local database:

```typescript
// First sync the conversations from the network to update the local db
await client.conversations.sync();

// Then get all messages as an array
const messages = await conversation.messages();
```

## Key Type References

```tsx
// Client Class
declare class Client {
  constructor(client: Client$1, signer: Signer, codecs: ContentCodec[]);
  static create(
    signer: Signer,
    encryptionKey: Uint8Array,
    options?: ClientOptions,
  ): Promise<Client>;
  get inboxId(): string;
  get installationId(): string;
  get conversations(): Conversations;
  get preferences(): Preferences;
}

// Conversations Class
declare class Conversations {
  constructor(client: Client, conversations: Conversations$1);
  getConversationById(id: string): Promise<Dm | Group | undefined>;
  newGroupWithIdentifiers(
    identifiers: Identifier[],
    options?: CreateGroupOptions,
  ): Promise<Group>;
  newGroup(inboxIds: string[], options?: CreateGroupOptions): Promise<Group>;
  newDmWithIdentifier(
    identifier: Identifier,
    options?: CreateDmOptions,
  ): Promise<Dm>;
  newDm(inboxId: string, options?: CreateDmOptions): Promise<Dm>;
  sync(): Promise<void>;
  streamAllMessages(
    callback?: StreamCallback<DecodedMessage>,
  ): Promise<AsyncStream<DecodedMessage<any>>>;
}

// Conversation Base Class
declare class Conversation {
  client: Client;
  constructor(
    client: Client,
    conversation: Conversation$1,
    lastMessage?: Message | null,
  );
  get id(): string;
  send<T>(content: T, options?: SendOptions): Promise<string>;
  messages<T>(options?: PaginationOptions): Promise<Array<DecodedMessage<T>>>;
  members(): Promise<GroupMember[]>;
}

// Dm Class
declare class Dm extends Conversation {
  constructor(
    client: Client,
    conversation: Conversation$1,
    lastMessage?: Message | null,
  );
  get peerInboxId(): string;
}

// Group Class
declare class Group extends Conversation {
  constructor(
    client: Client,
    conversation: Conversation$1,
    lastMessage?: Message | null,
  );
  get name(): string;
  updateName(name: string): Promise<void>;
  get imageUrl(): string;
  updateImageUrl(imageUrl: string): Promise<void>;
  get description(): string;
  updateDescription(description: string): Promise<void>;
  get admins(): string[];
  get superAdmins(): string[];
  isAdmin(inboxId: string): boolean;
  isSuperAdmin(inboxId: string): boolean;
  addMembersByIdentifiers(identifiers: Identifier[]): Promise<void>;
  addMembers(inboxIds: string[]): Promise<void>;
  removeMembers(inboxIds: string[]): Promise<void>;
  addAdmin(inboxId: string): Promise<void>;
  removeAdmin(inboxId: string): Promise<void>;
  addSuperAdmin(inboxId: string): Promise<void>;
  removeSuperAdmin(inboxId: string): Promise<void>;
}

// GroupMember Class
declare class GroupMember {
  inboxId: string;
  accountIdentifiers: Array<Identifier>;
  installationIds: Array<string>;
  permissionLevel: PermissionLevel;
  consentState: ConsentState;
}

// DecodedMessage Class
declare class DecodedMessage<T = any> {
  content: T;
  contentType: ContentTypeId | undefined;
  conversationId: string;
  id: string;
  senderInboxId: string;
  sentAt: Date;
  constructor(client: Client, message: Message);
}

// Identifier Interface
export interface Identifier {
  identifier: string;
  identifierKind: IdentifierKind;
}

export declare const enum IdentifierKind {
  Ethereum = 0,
  Passkey = 1,
}

// CreateGroupOptions Interface
export interface CreateGroupOptions {
  groupName?: string;
  groupImageUrlSquare?: string;
  groupDescription?: string;
}
```

### Common Usage Patterns

When working with these classes:

1. **Client**
   - Gateway to all XMTP functionality
   - Contains the conversations, contacts, and content types registries

2. **Conversations**
   - Central interface for managing all conversations
   - Use `sync()` before accessing local conversation data
   - Use `streamAllMessages()` to listen for new messages in real-time
   - Create conversations with `newDm()`, `newGroup()`, etc.

3. **Dm**
   - Access the peer using `conversation.peerInboxId`
   - Create new DMs with `client.conversations.newDm(inboxId)`
   - Send messages with `dm.send(content)`

4. **Group**
   - Get members with `await group.members();` (this works for DMs too)
   - Manage group metadata with `updateName()`, `updateDescription()`, etc.
   - Add/remove members with `addMembers()` and `removeMembers()`
   - Manage permissions with admin methods: `addAdmin()`, `addSuperAdmin()`, etc.
   - Check permissions with `isAdmin()` and `isSuperAdmin()`

5. **GroupMember**
   - Use `member.inboxId` to identify members
   - Access Ethereum addresses through `member.accountIdentifiers`
   - Access installation IDs through `member.installationIds`
   - Check permission level with `member.permissionLevel`
   - consent state with `member.consentState`

## Group Permissions System

XMTP provides a robust group permissions system that allows fine-grained control over who can perform specific actions within a group.

### Permission Types

There are 5 main permission types that can be configured:

```typescript
export declare const enum PermissionUpdateType {
  AddMember = 0, // Who can add new members to the group
  RemoveMember = 1, // Who can remove members from the group
  AddAdmin = 2, // Who can grant admin status to members
  RemoveAdmin = 3, // Who can remove admin status from members
  UpdateMetadata = 4, // Who can update group name, description, image
}
```

### Permission Policies

Each permission can be assigned one of 6 different policies:

```typescript
export declare const enum PermissionPolicy {
  Allow = 0, // All members can perform this action
  Deny = 1, // No one can perform this action
  Admin = 2, // Only admins can perform this action
  SuperAdmin = 3, // Only super admins can perform this action
  DoesNotExist = 4, // Permission doesn't exist (legacy)
  Other = 5, // Custom policy (reserved for future use)
}
```

### Member Roles

Group members can have different roles with varying levels of permissions:

- **Member**: Basic group participant
- **Admin**: Can perform admin-level actions (depends on group settings)
- **Super Admin**: Has all permissions and can manage other admins

### Default Permission Set

When a group is created, it uses the `All_Members` policy set by default:

```typescript
// Default permissions for new groups
const defaultPermissions = {
  AddMember: PermissionPolicy.Allow, // All members can add others
  RemoveMember: PermissionPolicy.Admin, // Only admins can remove members
  AddAdmin: PermissionPolicy.SuperAdmin, // Only super admins can add admins
  RemoveAdmin: PermissionPolicy.SuperAdmin, // Only super admins can remove admins
  UpdateMetadata: PermissionPolicy.Allow, // All members can update metadata
};
```

### Managing Group Permissions

```typescript
// Check if a member is an admin
const isAdmin = group.isAdmin(inboxId);
const isSuperAdmin = group.isSuperAdmin(inboxId);

// Get all admins and super admins
const admins = group.admins;
const superAdmins = group.superAdmins;

// Manage admin status
await group.addAdmin(inboxId);
await group.removeAdmin(inboxId);
await group.addSuperAdmin(inboxId);
await group.removeSuperAdmin(inboxId);
```

### Custom Permission Sets

You can create custom permission sets for specific use cases:

```typescript
// Example: Admin-only group
const adminOnlyPermissions = {
  AddMember: PermissionPolicy.Admin,
  RemoveMember: PermissionPolicy.Admin,
  AddAdmin: PermissionPolicy.SuperAdmin,
  RemoveAdmin: PermissionPolicy.SuperAdmin,
  UpdateMetadata: PermissionPolicy.Admin,
};

// Read-only group - only super admin can make changes
const readOnlyGroup = {
  AddMember: PermissionPolicy.SuperAdmin,
  RemoveMember: PermissionPolicy.SuperAdmin,
  AddAdmin: PermissionPolicy.SuperAdmin,
  RemoveAdmin: PermissionPolicy.SuperAdmin,
  UpdateMetadata: PermissionPolicy.SuperAdmin,
};
```

For more detailed information about XMTP group permissions, see the [official documentation](https://docs.xmtp.org/inboxes/group-permissions).

## Other Notes

### Handling local database paths

If no `dbPath` is provided, the client will use the current working directory. You can also specify a custom path for the database.

```jsx
// Railway deployment support
let volumePath = process.env.RAILWAY_VOLUME_MOUNT_PATH ?? ".data/xmtp";
const dbPath = `${volumePath}/${signer.getIdentifier()}-${XMTP_ENV}`;

// Create database directory if it doesn't exist
if (!fs.existsSync(dbPath)) {
  fs.mkdirSync(dbPath, { recursive: true });
}

// Create a client with db path
const client = await Client.create(signer, {
  dbEncryptionKey,
appVersion:"example-agent/1.0.0",
  env: XMTP_ENV as XmtpEnv,
  // Use a unique DB directory
  dbPath,
});
```
